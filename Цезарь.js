let fs = require('fs');
//Массив частот оригинального алфавита
let CF_ENG = [0.0804, 0.0154, 0.0306, 0.0399, 0.1251, 0.0230, 0.0196, 0.0549, 0.0726, 0.0016, 0.0067, 0.0414, 0.0253, 0.0709, 0.0760, 0.0200, 0.0011, 0.0612, 0.0654, 0.0925, 0.0271, 0.0099, 0.0192, 0.0019, 0.0173, 0.0009];
//Массив частот зашифрованного текста
let FF = new Array();
//Длинна алфавита
let len = 26;

//Объявление и инициолизация оригинального алфавита
let alph = new Object();
let ArrayAlph = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];
ArrayAlph.forEach(element => {          //данная конструкция позволяет заполнить объект alph ключами, которые являются элементами массива ArrayAlph, и установить для каждого ключа значение 1
    alph[element]=1;                    //предположим, что ArrayAlph = ['a', 'b', 'c'] после выполнения данной конструкции, объект alph будет иметь вид: {a: 1, b: 1, c: 1}
});
// alph - словарь, в котором значению ключу - букве алфавита, будет соответствовать количество его вхождений во всём тексте

let inText = fs.readFileSync('King Stephen. Dolans Cadillac - royallib.ru.txt', 'utf8').toString();     //Чтение файла

//подсчёт вхождений каждого символа (не буквы кодироваться не будут) и подсчёт количества всех букв
let totalLenght = 0;        //переменная для хранения количества букв в тексте
for(let element in inText){     //цикл прохода по каждому элементу в тексте
    let symbol = inText[element].toLowerCase();     //сохраняем в symbol символ текста в нижнем регистре
    if(alph[symbol]){                   //условие на наличие данного символа в словаре
        alph[symbol]++;                 //добавляем к счетчику буквы единицу
        totalLenght++;                  //добавляем в количество использованных букв в тексте единицу
    }
}
//console.log(alph)
let totalRemove = 12;       //данной переменной задаем сдвиг алфавита для шифрования

let i = 0;      //переменная отвечающая за позицию буквы, дабы добавить к ней сдвиг
for(let symbol in alph){        //проходимся по словарю и реализуем "сдвиг"
    let index = (i+totalRemove)%len;        //переменная отвечающая за свдиг каждого символа
    FF[index] = (alph[symbol]-1)/totalLenght;       //создаем частоту для чужого(сдвинутого) символа
    i++;    //добавляем единицу в позицию, чтобы сдвинуть следующий символ
}


//Декодирование
let bing = new Array(); //создаём массив, в который будем передавать сумму квадратов разности между оригинальным алфавитом и сдвинутым

for(let j = 0; j < len; j++){       //заполняем массив 26-ью нулями
    bing[j]=0;
}

let argMin = 0;         //перемення для сдвига передаваемого алфавита, при котором сумма минимальна 
let minFun = 10000000;      //минимальная сумма(заведомо берём очень большое значение)
//подсчёт всех сумм квадратов расстаяний
for(let k = 0; k < len; k++){   //цикл отвечающий за индекс записи в bing, соответственно k будет соответствовать сдвигу
    for(let i = 0; i < len; i++){   //цикл отвечающий за позицию частот каждой буквы
        bing[k] += ((CF_ENG[i] - FF[(i+k)%len])*(CF_ENG[i] - FF[(i+k)%len]));   //подсчет суммы квадратов разности между оригинальным алфавитом и сдвинутым
    }
    //выявляем минимальную сумму(если minFun наименьший, то для данного значения запоминаем argMin, который и будет предполагаемым сдвигом алфавита)
    if (bing[k] < minFun){
        minFun = bing[k];
        argMin = k;
    }
}

console.log("Сдвиг алфавита равен: ",argMin);
